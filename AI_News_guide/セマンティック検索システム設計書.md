# セマンティック検索システム設計書

## 概要
ユーザーの自然な言葉を理解し、最適なニュースを届けるセマンティック検索システムの詳細設計書です。Gemini 2.5 Flash APIを活用して、複雑な検索意図を解析し、タグベースの検索条件に変換します。

## システム構成

### 1. 検索フロー全体像
```
ユーザー入力
    ↓
Gemini Flash意図解析
    ↓
タグ条件生成
    ↓
データベース検索
    ↓
結果の最適化
    ↓
ユーザーへ表示
```

## 実装詳細

### 1. セマンティック検索エンジン

`lib/search/semantic-search.ts`:

```typescript
import { geminiFlash } from '../ai/gemini';
import { supabase } from '../supabase';

export interface SearchIntent {
  required_tags: string[];      // 必須タグ
  preferred_tags: string[];     // 推奨タグ
  excluded_tags: string[];      // 除外タグ
  date_range?: {
    from: string;
    to: string;
  };
  trust_level?: number;         // 必要な信頼度レベル（1-10）
  importance_threshold?: number; // 重要度の閾値
  limit?: number;               // 取得件数
  special_conditions?: string[]; // その他の特殊条件
}

export interface SearchResult {
  articles: Article[];
  search_intent: SearchIntent;
  total_count: number;
  search_time_ms: number;
}

// ユーザーのクエリを解析
export async function parseUserQuery(query: string): Promise<SearchIntent> {
  const prompt = `
ユーザーの検索クエリを分析して、検索意図をJSON形式で返してください。

クエリ: "${query}"

以下の形式で返してください：
{
  "required_tags": ["必須タグ1", "必須タグ2"],
  "preferred_tags": ["推奨タグ1", "推奨タグ2"],
  "excluded_tags": ["除外タグ1", "除外タグ2"],
  "date_range": {
    "from": "YYYY-MM-DD",
    "to": "YYYY-MM-DD"
  },
  "trust_level": 信頼度レベル（1-10、指定がない場合はnull）,
  "importance_threshold": 重要度の閾値（1-10、指定がない場合はnull）,
  "limit": 取得件数（指定がない場合は20）,
  "special_conditions": ["特殊条件1", "特殊条件2"]
}

解析のルール：
1. 企業名が含まれる場合は、その企業をrequired_tagsに追加
2. "公式"、"オフィシャル"などの言葉がある場合は、trust_levelを9以上に設定
3. "最新"、"今日"、"今週"などの時間指定がある場合は、適切なdate_rangeを設定
4. "〜以外"、"〜を除く"などの否定表現は、excluded_tagsに追加
5. 価格帯の指定がある場合は、適切な価格帯タグをrequired_tagsに追加
6. 評価に関する言葉（"評判がいい"、"人気"など）は、適切な評価タグをpreferred_tagsに追加

例：
- "OpenAIの公式情報だけ" → required_tags: ["OpenAI"], trust_level: 9
- "1500円くらいのインディーゲーム" → required_tags: ["インディー", "1000-3000円"]
- "今週のAI関連ニュース" → required_tags: ["AI"], date_range: 今週の日付範囲
`;

  try {
    const result = await geminiFlash.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    // JSON部分を抽出
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('JSON形式の応答が見つかりません');
    }
    
    const intent = JSON.parse(jsonMatch[0]);
    
    // デフォルト値の設定
    return {
      required_tags: intent.required_tags || [],
      preferred_tags: intent.preferred_tags || [],
      excluded_tags: intent.excluded_tags || [],
      date_range: intent.date_range,
      trust_level: intent.trust_level,
      importance_threshold: intent.importance_threshold,
      limit: intent.limit || 20,
      special_conditions: intent.special_conditions || []
    };
  } catch (error) {
    console.error('クエリ解析エラー:', error);
    // フォールバック: 単純なキーワード検索として扱う
    return {
      required_tags: query.split(' ').filter(word => word.length > 1),
      preferred_tags: [],
      excluded_tags: [],
      limit: 20
    };
  }
}

// 検索意図に基づいて記事を検索
export async function searchArticles(intent: SearchIntent): Promise<SearchResult> {
  const startTime = Date.now();
  
  try {
    // タグ名からタグIDを取得
    const allTagNames = [
      ...intent.required_tags,
      ...intent.preferred_tags,
      ...intent.excluded_tags
    ];
    
    const { data: tags } = await supabase
      .from('tag_master')
      .select('id, tag_name')
      .in('tag_name', allTagNames);
    
    const tagNameToId = new Map(
      tags?.map(tag => [tag.tag_name, tag.id]) || []
    );
    
    // 必須タグのIDリスト
    const requiredTagIds = intent.required_tags
      .map(name => tagNameToId.get(name))
      .filter(Boolean) as string[];
    
    // 除外タグのIDリスト
    const excludedTagIds = intent.excluded_tags
      .map(name => tagNameToId.get(name))
      .filter(Boolean) as string[];
    
    // メインクエリの構築
    let query = supabase
      .from('news_articles')
      .select(`
        *,
        article_tags!inner (
          tag_id,
          confidence_score,
          tag_master!inner (
            tag_name,
            category
          )
        )
      `)
      .order('importance_score', { ascending: false })
      .order('published_at', { ascending: false })
      .limit(intent.limit || 20);
    
    // 日付範囲の適用
    if (intent.date_range) {
      if (intent.date_range.from) {
        query = query.gte('published_at', intent.date_range.from);
      }
      if (intent.date_range.to) {
        query = query.lte('published_at', intent.date_range.to);
      }
    }
    
    // 重要度閾値の適用
    if (intent.importance_threshold) {
      query = query.gte('importance_score', intent.importance_threshold);
    }
    
    // 必須タグの適用（AND条件）
    if (requiredTagIds.length > 0) {
      // 各必須タグを持つ記事のみを取得
      for (const tagId of requiredTagIds) {
        query = query.eq('article_tags.tag_id', tagId);
      }
    }
    
    // 信頼度レベルの適用
    if (intent.trust_level) {
      query = query.gte('article_tags.confidence_score', intent.trust_level / 10);
    }
    
    const { data: articles, error, count } = await query;
    
    if (error) {
      throw error;
    }
    
    // 除外タグを持つ記事をフィルタリング
    let filteredArticles = articles || [];
    if (excludedTagIds.length > 0) {
      filteredArticles = filteredArticles.filter(article => {
        const articleTagIds = article.article_tags.map(at => at.tag_id);
        return !excludedTagIds.some(excludeId => articleTagIds.includes(excludeId));
      });
    }
    
    // 推奨タグによるスコアリング
    const preferredTagIds = intent.preferred_tags
      .map(name => tagNameToId.get(name))
      .filter(Boolean) as string[];
    
    if (preferredTagIds.length > 0) {
      filteredArticles = filteredArticles.map(article => {
        const articleTagIds = article.article_tags.map(at => at.tag_id);
        const preferredCount = preferredTagIds.filter(prefId => 
          articleTagIds.includes(prefId)
        ).length;
        
        return {
          ...article,
          relevance_score: article.importance_score + (preferredCount * 0.5)
        };
      }).sort((a, b) => b.relevance_score - a.relevance_score);
    }
    
    const endTime = Date.now();
    
    return {
      articles: filteredArticles,
      search_intent: intent,
      total_count: filteredArticles.length,
      search_time_ms: endTime - startTime
    };
    
  } catch (error) {
    console.error('記事検索エラー:', error);
    throw error;
  }
}

// 検索履歴を記録
export async function recordSearchHistory(
  userId: string,
  query: string,
  intent: SearchIntent,
  resultCount: number
) {
  try {
    const { error } = await supabase
      .from('user_search_history')
      .insert({
        user_id: userId,
        search_query: query,
        parsed_intent: intent,
        result_count: resultCount
      });
    
    if (error) {
      console.error('検索履歴記録エラー:', error);
    }
  } catch (error) {
    console.error('検索履歴記録エラー:', error);
  }
}

// クリックした記事を記録
export async function recordClickedArticle(
  searchHistoryId: string,
  articleId: string
) {
  try {
    // 現在のクリック記事を取得
    const { data: history } = await supabase
      .from('user_search_history')
      .select('clicked_articles')
      .eq('id', searchHistoryId)
      .single();
    
    if (history) {
      const clickedArticles = history.clicked_articles || [];
      if (!clickedArticles.includes(articleId)) {
        clickedArticles.push(articleId);
        
        await supabase
          .from('user_search_history')
          .update({ clicked_articles: clickedArticles })
          .eq('id', searchHistoryId);
      }
    }
  } catch (error) {
    console.error('クリック記録エラー:', error);
  }
}
```

### 2. 検索UIコンポーネント

`components/search/SemanticSearchBox.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { Search, Loader2, X } from 'lucide-react';
import { parseUserQuery, searchArticles } from '@/lib/search/semantic-search';

export function SemanticSearchBox() {
  const [query, setQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [searchIntent, setSearchIntent] = useState(null);
  const [results, setResults] = useState(null);
  const [showIntentDebug, setShowIntentDebug] = useState(false);

  const handleSearch = async () => {
    if (!query.trim() || isSearching) return;
    
    setIsSearching(true);
    try {
      // 意図解析
      const intent = await parseUserQuery(query);
      setSearchIntent(intent);
      
      // 記事検索
      const searchResults = await searchArticles(intent);
      setResults(searchResults);
      
      // 検索履歴を記録（ユーザーIDが利用可能な場合）
      // await recordSearchHistory(userId, query, intent, searchResults.total_count);
      
    } catch (error) {
      console.error('検索エラー:', error);
    } finally {
      setIsSearching(false);
    }
  };

  const examples = [
    'OpenAIの最新情報',
    '1000円以下のゲーム',
    '今週のAI関連ニュース',
    'Googleの公式発表だけ',
    '評判がいいインディーゲーム'
  ];

  return (
    <div className="w-full max-w-4xl mx-auto">
      {/* 検索ボックス */}
      <div className="relative">
        <div className="flex items-center gap-2 p-4 bg-white rounded-lg shadow-lg border border-gray-200">
          <Search className="w-5 h-5 text-gray-400" />
          <input
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
            placeholder="見たいニュースを教えてください..."
            className="flex-1 outline-none text-lg"
          />
          {query && (
            <button
              onClick={() => {
                setQuery('');
                setSearchIntent(null);
                setResults(null);
              }}
              className="p-1 hover:bg-gray-100 rounded"
            >
              <X className="w-4 h-4 text-gray-400" />
            </button>
          )}
          <button
            onClick={handleSearch}
            disabled={!query.trim() || isSearching}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSearching ? (
              <Loader2 className="w-5 h-5 animate-spin" />
            ) : (
              '検索'
            )}
          </button>
        </div>
      </div>

      {/* 検索例 */}
      {!searchIntent && (
        <div className="mt-4">
          <p className="text-sm text-gray-500 mb-2">例：</p>
          <div className="flex flex-wrap gap-2">
            {examples.map((example, i) => (
              <button
                key={i}
                onClick={() => setQuery(example)}
                className="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-full transition-colors"
              >
                {example}
              </button>
            ))}
          </div>
        </div>
      )}

      {/* 検索意図の表示 */}
      {searchIntent && (
        <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
          <div className="flex items-center justify-between mb-2">
            <h3 className="font-semibold text-blue-900">検索条件を理解しました</h3>
            <button
              onClick={() => setShowIntentDebug(!showIntentDebug)}
              className="text-sm text-blue-600 hover:underline"
            >
              {showIntentDebug ? '詳細を隠す' : '詳細を見る'}
            </button>
          </div>
          
          <div className="space-y-2 text-sm">
            {searchIntent.required_tags.length > 0 && (
              <div className="flex items-start gap-2">
                <span className="text-blue-700">✓ 必須：</span>
                <div className="flex flex-wrap gap-1">
                  {searchIntent.required_tags.map((tag, i) => (
                    <span key={i} className="px-2 py-0.5 bg-blue-100 rounded">
                      {tag}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            {searchIntent.preferred_tags.length > 0 && (
              <div className="flex items-start gap-2">
                <span className="text-blue-700">✓ 推奨：</span>
                <div className="flex flex-wrap gap-1">
                  {searchIntent.preferred_tags.map((tag, i) => (
                    <span key={i} className="px-2 py-0.5 bg-green-100 rounded">
                      {tag}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            {searchIntent.excluded_tags.length > 0 && (
              <div className="flex items-start gap-2">
                <span className="text-blue-700">✗ 除外：</span>
                <div className="flex flex-wrap gap-1">
                  {searchIntent.excluded_tags.map((tag, i) => (
                    <span key={i} className="px-2 py-0.5 bg-red-100 rounded">
                      {tag}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            {searchIntent.date_range && (
              <div>
                <span className="text-blue-700">✓ 期間：</span>
                <span className="ml-2">
                  {searchIntent.date_range.from} 〜 {searchIntent.date_range.to}
                </span>
              </div>
            )}
            
            {searchIntent.trust_level && (
              <div>
                <span className="text-blue-700">✓ 信頼度：</span>
                <span className="ml-2">{searchIntent.trust_level}/10 以上</span>
              </div>
            )}
          </div>
          
          {showIntentDebug && (
            <pre className="mt-3 p-2 bg-white rounded text-xs overflow-auto">
              {JSON.stringify(searchIntent, null, 2)}
            </pre>
          )}
        </div>
      )}

      {/* 検索結果 */}
      {results && (
        <div className="mt-6">
          <p className="text-gray-600 mb-4">
            {results.total_count}件の記事が見つかりました
            <span className="text-sm text-gray-400 ml-2">
              ({results.search_time_ms}ms)
            </span>
          </p>
          
          <div className="space-y-4">
            {results.articles.map((article) => (
              <ArticleCard
                key={article.id}
                article={article}
                onClickRecord={() => {
                  // クリック記録の実装
                }}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

### 3. パーソナライゼーション機能

`lib/personalization/user-preferences.ts`:

```typescript
import { supabase } from '../supabase';

// ユーザーの嗜好を分析して更新
export async function updateUserPreferences(userId: string) {
  try {
    // 過去30日間の検索履歴を取得
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const { data: searchHistory } = await supabase
      .from('user_search_history')
      .select('*')
      .eq('user_id', userId)
      .gte('created_at', thirtyDaysAgo.toISOString())
      .order('created_at', { ascending: false });
    
    if (!searchHistory || searchHistory.length === 0) {
      return;
    }
    
    // クリックされた記事を分析
    const clickedArticleIds = searchHistory
      .flatMap(h => h.clicked_articles || []);
    
    const { data: clickedArticles } = await supabase
      .from('news_articles')
      .select(`
        *,
        article_tags (
          tag_id,
          confidence_score,
          tag_master (
            id,
            tag_name,
            category
          )
        )
      `)
      .in('id', clickedArticleIds);
    
    // タグの出現頻度を計算
    const tagFrequency = new Map<string, number>();
    const tagClickRate = new Map<string, number>();
    
    clickedArticles?.forEach(article => {
      article.article_tags.forEach(at => {
        const tagId = at.tag_master.id;
        tagFrequency.set(tagId, (tagFrequency.get(tagId) || 0) + 1);
      });
    });
    
    // 検索されたが、クリックされなかったタグも分析
    const searchedTags = new Set<string>();
    searchHistory.forEach(history => {
      const intent = history.parsed_intent;
      [...(intent.required_tags || []), ...(intent.preferred_tags || [])]
        .forEach(tag => searchedTags.add(tag));
    });
    
    // 好むタグと避けるタグを判定
    const preferredTags: string[] = [];
    const excludedTags: string[] = [];
    const tagWeights: Record<string, number> = {};
    
    tagFrequency.forEach((count, tagId) => {
      const clickRate = count / clickedArticleIds.length;
      
      if (clickRate > 0.3) {
        preferredTags.push(tagId);
        tagWeights[tagId] = 1 + (clickRate * 0.5);
      } else if (clickRate < 0.05) {
        excludedTags.push(tagId);
        tagWeights[tagId] = 0.5;
      }
    });
    
    // 閲覧パターンの分析
    const readingPatterns = {
      average_reading_time: calculateAverageReadingTime(searchHistory),
      preferred_categories: calculatePreferredCategories(clickedArticles),
      active_hours: calculateActiveHours(searchHistory),
      click_through_rate: clickedArticleIds.length / searchHistory.length,
      topics_interest: calculateTopicsInterest(clickedArticles)
    };
    
    // user_preferencesを更新
    const { error } = await supabase
      .from('user_preferences')
      .upsert({
        user_id: userId,
        preferred_tags: preferredTags,
        excluded_tags: excludedTags,
        tag_weights: tagWeights,
        reading_patterns: readingPatterns,
        last_calculated_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });
    
    if (error) {
      console.error('ユーザー嗜好更新エラー:', error);
    }
    
  } catch (error) {
    console.error('ユーザー嗜好分析エラー:', error);
  }
}

// ヘルパー関数
function calculateAverageReadingTime(searchHistory: any[]): number {
  // 実装: クリック間隔から推定
  return 120; // 仮の値
}

function calculatePreferredCategories(articles: any[]): string[] {
  const categoryCount = new Map<string, number>();
  articles?.forEach(article => {
    const category = article.category;
    categoryCount.set(category, (categoryCount.get(category) || 0) + 1);
  });
  
  return Array.from(categoryCount.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([category]) => category);
}

function calculateActiveHours(searchHistory: any[]): number[] {
  const hourCount = new Map<number, number>();
  searchHistory.forEach(history => {
    const hour = new Date(history.created_at).getHours();
    hourCount.set(hour, (hourCount.get(hour) || 0) + 1);
  });
  
  return Array.from(hourCount.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 4)
    .map(([hour]) => hour);
}

function calculateTopicsInterest(articles: any[]): Record<string, number> {
  // 仮の実装
  return {
    technical_details: 0.8,
    business_impact: 0.3,
    product_announcements: 0.9
  };
}
```

## 検索クエリの例と解析結果

### 例1: 「OpenAIの公式情報だけ見たい」
```json
{
  "required_tags": ["OpenAI"],
  "preferred_tags": ["公式発表", "新製品発表"],
  "excluded_tags": ["憶測", "噂", "予想"],
  "trust_level": 9,
  "importance_threshold": null,
  "limit": 20
}
```

### 例2: 「1500円くらいの最新インディーゲームで評判いいやつ」
```json
{
  "required_tags": ["インディー", "1000-3000円"],
  "preferred_tags": ["非常に好評", "圧倒的に好評"],
  "excluded_tags": ["不評", "賛否両論"],
  "date_range": {
    "from": "2024-12-15",
    "to": "2025-01-15"
  },
  "limit": 20
}
```

### 例3: 「今週のAI関連ニュースで重要なものだけ」
```json
{
  "required_tags": ["AI"],
  "preferred_tags": ["革新的", "重要"],
  "excluded_tags": [],
  "date_range": {
    "from": "2025-01-19",
    "to": "2025-01-25"
  },
  "importance_threshold": 7.0,
  "limit": 20
}
```

## パフォーマンス最適化

### 1. インデックスの活用
- タグ検索の高速化
- 日付範囲検索の最適化
- 重要度スコアでのソート

### 2. キャッシュ戦略
- 頻繁に検索されるクエリの結果をキャッシュ
- タグマスターのメモリキャッシュ
- ユーザー嗜好の定期更新（リアルタイムではない）

### 3. 非同期処理
- 検索履歴の記録は非同期
- パーソナライゼーション計算はバックグラウンド
- クリック記録は非ブロッキング

## まとめ

このセマンティック検索システムにより、ユーザーは自然な言葉でニュースを検索でき、システムは検索意図を正確に理解して最適な結果を返します。また、ユーザーの行動を学習することで、より精度の高いパーソナライゼーションを実現します。