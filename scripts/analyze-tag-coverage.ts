import { supabase } from '@/lib/supabase'

async function analyzeTagCoverage() {
  console.log('ğŸ” è¨˜äº‹ã‚¿ã‚°ã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æé–‹å§‹...\n')
  
  try {
    // 1. å…¨è¨˜äº‹æ•°ã®å–å¾—
    const { data: allArticles, error: allError } = await supabase
      .from('news_articles')
      .select('id, title, category, source_name, created_at')
      .order('created_at', { ascending: false })
    
    if (allError) {
      console.error('âŒ å…¨è¨˜äº‹å–å¾—ã‚¨ãƒ©ãƒ¼:', allError)
      return
    }
    
    console.log(`ğŸ“Š å…¨è¨˜äº‹æ•°: ${allArticles?.length || 0}ä»¶`)
    
    // 2. ã‚¿ã‚°ä»˜ãè¨˜äº‹æ•°ã®å–å¾—
    const { data: taggedArticles, error: taggedError } = await supabase
      .from('news_articles')
      .select(`
        id, 
        title, 
        category,
        source_name,
        created_at,
        article_tags(
          tag_name,
          confidence_score,
          is_auto_generated
        )
      `)
      .not('article_tags', 'is', null)
      .order('created_at', { ascending: false })
    
    if (taggedError) {
      console.error('âŒ ã‚¿ã‚°ä»˜ãè¨˜äº‹å–å¾—ã‚¨ãƒ©ãƒ¼:', taggedError)
      return
    }
    
    console.log(`ğŸ“Š ã‚¿ã‚°ä»˜ãè¨˜äº‹æ•°: ${taggedArticles?.length || 0}ä»¶`)
    
    // 3. ã‚¿ã‚°ãªã—è¨˜äº‹ã®ç‰¹å®š
    const taggedArticleIds = new Set(taggedArticles?.map(a => a.id) || [])
    const untaggedArticles = allArticles?.filter(article => 
      !taggedArticleIds.has(article.id)
    ) || []
    
    console.log(`ğŸ“Š ã‚¿ã‚°ãªã—è¨˜äº‹æ•°: ${untaggedArticles.length}ä»¶`)
    console.log(`ğŸ“Š ã‚¿ã‚°ã‚«ãƒãƒ¬ãƒƒã‚¸: ${Math.round((taggedArticles?.length || 0) / (allArticles?.length || 1) * 100)}%\n`)
    
    // 4. ã‚«ãƒ†ã‚´ãƒªåˆ¥åˆ†æ
    console.log('ğŸ“‹ ã‚«ãƒ†ã‚´ãƒªåˆ¥ã‚¿ã‚°ã‚«ãƒãƒ¬ãƒƒã‚¸:')
    const categoryStats: { [key: string]: { total: number, tagged: number } } = {}
    
    // å…¨è¨˜äº‹ã‚’ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«é›†è¨ˆ
    allArticles?.forEach(article => {
      if (!categoryStats[article.category]) {
        categoryStats[article.category] = { total: 0, tagged: 0 }
      }
      categoryStats[article.category].total++
    })
    
    // ã‚¿ã‚°ä»˜ãè¨˜äº‹ã‚’ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«é›†è¨ˆ
    taggedArticles?.forEach(article => {
      if (categoryStats[article.category]) {
        categoryStats[article.category].tagged++
      }
    })
    
    Object.entries(categoryStats).forEach(([category, stats]) => {
      const coverage = Math.round(stats.tagged / stats.total * 100)
      console.log(`   ${category}: ${stats.tagged}/${stats.total} (${coverage}%)`)
    })
    
    // 5. ã‚½ãƒ¼ã‚¹åˆ¥åˆ†æ
    console.log('\nğŸ“‹ ã‚½ãƒ¼ã‚¹åˆ¥ã‚¿ã‚°ã‚«ãƒãƒ¬ãƒƒã‚¸:')
    const sourceStats: { [key: string]: { total: number, tagged: number } } = {}
    
    // å…¨è¨˜äº‹ã‚’ã‚½ãƒ¼ã‚¹åˆ¥ã«é›†è¨ˆ
    allArticles?.forEach(article => {
      if (!sourceStats[article.source_name]) {
        sourceStats[article.source_name] = { total: 0, tagged: 0 }
      }
      sourceStats[article.source_name].total++
    })
    
    // ã‚¿ã‚°ä»˜ãè¨˜äº‹ã‚’ã‚½ãƒ¼ã‚¹åˆ¥ã«é›†è¨ˆ
    taggedArticles?.forEach(article => {
      if (sourceStats[article.source_name]) {
        sourceStats[article.source_name].tagged++
      }
    })
    
    Object.entries(sourceStats)
      .sort((a, b) => b[1].total - a[1].total)
      .forEach(([source, stats]) => {
        const coverage = Math.round(stats.tagged / stats.total * 100)
        console.log(`   ${source}: ${stats.tagged}/${stats.total} (${coverage}%)`)
      })
    
    // 6. ã‚¿ã‚°ãªã—è¨˜äº‹ã®è©³ç´°ï¼ˆæœ€æ–°10ä»¶ï¼‰
    if (untaggedArticles.length > 0) {
      console.log('\nâŒ ã‚¿ã‚°ãªã—è¨˜äº‹ï¼ˆæœ€æ–°10ä»¶ï¼‰:')
      untaggedArticles.slice(0, 10).forEach((article, index) => {
        console.log(`   ${index + 1}. [${article.category}] ${article.title}`)
        console.log(`      ã‚½ãƒ¼ã‚¹: ${article.source_name} | ä½œæˆ: ${new Date(article.created_at).toLocaleDateString()}`)
      })
    }
    
    // 7. ã‚¿ã‚°çµ±è¨ˆ
    console.log('\nğŸ·ï¸ ã‚¿ã‚°çµ±è¨ˆ:')
    const { data: tagStats, error: tagStatsError } = await supabase
      .from('article_tags')
      .select('tag_name, is_auto_generated')
    
    if (!tagStatsError && tagStats) {
      const autoGenerated = tagStats.filter(t => t.is_auto_generated).length
      const predefined = tagStats.filter(t => !t.is_auto_generated).length
      console.log(`   ç·ã‚¿ã‚°æ•°: ${tagStats.length}å€‹`)
      console.log(`   è‡ªå‹•ç”Ÿæˆ: ${autoGenerated}å€‹`)
      console.log(`   äº‹å‰å®šç¾©: ${predefined}å€‹`)
    }
    
    // 8. æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    console.log('\nğŸ’¡ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:')
    if (untaggedArticles.length > 0) {
      console.log(`   â— ${untaggedArticles.length}ä»¶ã®è¨˜äº‹ã«ã‚¿ã‚°ä»˜ã‘ãŒå¿…è¦ã§ã™`)
      console.log('   ğŸ”§ é¡åŠAIåˆ†æã®å®Ÿè¡Œã‚’æ¨å¥¨ã—ã¾ã™')
      console.log('   ğŸ“ ã‚³ãƒãƒ³ãƒ‰: npx tsx scripts/retroactive-tag-articles.ts')
    }
    
    if ((taggedArticles?.length || 0) / (allArticles?.length || 1) < 0.8) {
      console.log('   âš ï¸ ã‚¿ã‚°ã‚«ãƒãƒ¬ãƒƒã‚¸ãŒ80%æœªæº€ã§ã™')
      console.log('   ğŸ”§ AIåˆ†æã‚·ã‚¹ãƒ†ãƒ ã®æ”¹å–„ãŒå¿…è¦ã§ã™')
    }
    
  } catch (error) {
    console.error('âŒ åˆ†æã‚¨ãƒ©ãƒ¼:', error)
  }
}

// å®Ÿè¡Œ
analyzeTagCoverage()